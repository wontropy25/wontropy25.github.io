---
title: "[컴퓨테이션이론] 1.1. Finite Automata"
date: 2024-09-09 00:01:00 +0900
categories: [학부 수업, (3-2) Computation Theory]
tags: [computation]     # TAG names should always be lowercase
math: true
mermaid: true
header-includes: 
  - \usepackage{tikz}
  - \usepackage{pgfplots}
---

> $\text{Introduction to the Theory of Computation (3th Edition)}$ <br/>
 $\text{Part 1. Finite Automata} \ (\text{p.}31 \sim \text{p.}??)$
{: .prompt-info}

### [1.1.1] Automatic Door Controller
---
- 실제 컴퓨터는 매우 복잡하기 때문에, 우리는 필수적인 기능만 가진 모델을 살펴볼 것이다. 지금부터 살펴볼 가장 단순한 모델은 $\text{finite automaton (finite state machine)}$ 이라고 한다.
- 먼저 자동문 컨트롤러의 예시를 통해 $\text{state diagram}$ 이 무엇인지 알아보자.
![1-1](assets/img/school_comp/co1-1.png)
- 위의 자동문은 front나 rear에 사람이 오면 rear 방향으로 문이 열리는 구조이다. 컨트롤러는 $\text{OPEN}$ 과 $\text{CLOSED}$ 두 가지 상태를 가질 수 있다. 문이 가질 수 있는 모든 상황을 그림으로 나타낸 것이 아래 $\text{state diagram}$이다.
![1-2](assets/img/school_comp/co1-2.png)

### [1.1.2] Finite Automaton
---
이제 실제 Finite Automaton이 어떻게 생겼는지 확인해보자. 아래는 $M_1$의 $\text{finite automaton}$을 $\text{state diagram}$으로 그린 그림이다.
![1-3](assets/img/school_comp/co1-3.png)
- $\textbf{start state}$: 시작 화살표가 가리키는 첫 지점인 $q_1$ 상태
- $\textbf{accept state}$: double circle이 그려진 $q_2$ 상태
- $\textbf{transitions}$: state와 state 사이를 이동하는 화살표

위의 Automaton에 어떤 input string을 넣으면 그 결과는 $\textbf{accept}$ 또는  $\textbf{reject}$가 나오게 된다. 예를 들어 $M_1$에 $1101$을 삽입하면 $q_1 \rightarrow q_2 \rightarrow q_3 \rightarrow q_2$가 되어 $\text{accept state}$에서 종료되었으므로 $\text{accept}$가 결과가 된다.

#### Formal Definition of a Finite Automaton
Finite Automaton은 $(Q, \Sigma, \delta, q_0, F)$로 이루어진 $\text{5-tuple}$ 이다. 
1. $Q: \text{states}$ 들을 모은 유한한 집합
2. $\Sigma: \text{alphabet}$ (symbol들의 유한한 집합)
3. $\delta: Q \times \Sigma \to Q$ - $\text{transition function}$ (예시: $\delta(x, 1) = y\ :\ x$에서 $1$을 입력하면 $y$로 간다)
4. $q_0 \in Q$: $\text{start state}$
5. $F \subseteq Q$: $\text{accept states (goal states)}$ ($F = \emptyset$이면 accpet state가 없을 수도 있다.)

<br />

이제 위의 $M_1$의 State Diagram을 Formal Definition으로 나타내보자.
![1-3](assets/img/school_comp/co1-3.png)

1. $Q$ $$= \{q_1, q_2, q_3\}$$
2. $\Sigma$ $$= \{0, 1\}$$
3. $\delta = $
$$ 
\begin{array}{c|cc}
    & 0 & 1 \\
    \hline
    q_1 & q_1 & q_2 \\
    q_2 & q_3 & q_2 \\
    q_3 & q_2 & q_2 \\
\end{array}
$$
4. $q_0 = q_1\ (\text{start state})$
5. $F$ $$ = \{q_2\}$$

이를 튜플로 나타내면 $$(\{q_1, q_2, q_3 \}, \{0, 1\}, \delta, q_1, \{ q_2 \})$$와 같이 나타낼 수 있다.

- $A$가 machine $M$이 accpet하는 모든 string들의 집합이면 $A\ \text{is the}\ \textbf{language of machine}\ M$ 이라 하고, 이를 $L(M)=A$라 쓴다.
- machine 기준에서는 $M\ \textbf{recognizes}\ A$ 또는 $M\ \textbf{accepts}\ A$라고 한다.
- 위의 $L(M_1)$을 accpet하는 $A$는 다음과 같다.

$$A = \{w \mid w \text{ contains at least one 1 and an even number of 0s following the last 1}\}$$

이제 여러가지 Finite automata들의 Formal description과 이를 accpet하는 Language를 알아보자.

#### Finite Automaton $M_2$
![1-4](assets/img/school_comp/co1-4.png)

- $$M_2$$ $$= (\{q_1, q_2\}, \{0, 1\}, \delta, q_1, \{q_2\})$$
- $$L(M_2)$$ $$= \{w \mid w\text{ ends in a 1}\}$$

#### Finite Automaton $M_3$
![1-5](assets/img/school_comp/co1-5.png)

- $M_3$는 $M_2$와 거의 똑같지만, Start state가 $q_1$이다. 이런 경우, Language는 **empty set**을 허용하게 된다!!
- $$
L(M_3)$$ $$= \{w \mid w \text{ is the empty string } \varepsilon \text{ or ends in a 0}\}.
$$

#### Finite Automaton $M_4$
![1-6](assets/img/school_comp/co1-6.png)

- $M_4$는 $a$로 가면 왼쪽 덩어리에서만 움직이고, $b$로 가면 오른쪽 덩어리에서만 움직인다. 그리고 각 덩어리는 $M_3$와 같은 형태로 만들어져있다.
- $$
L(M_4)$$ $$= \{\text{all strings that start and end with }a\ \text{or that shart and end with } b\}.
$$

#### Finite Automaton $M_5$
![1-7](assets/img/school_comp/co1-7.png)

- $$
\Sigma = \{\langle \text{RESET} \rangle, 0, 1, 2\}.
$$ 여기서  $\text{RESET}$도 하나의 symbol로 취급한다.
- $M_5$는 $3$비트 카운터의 역할을 한다. 카운트의 합을 3으로 나눈 값($\mod3$)을 계산해서 나머지가 0일 때만 accept 하는 기계이다.
- $$
L(M_5) = \{w \mid \text{the sum of the symbols in } w \text{ is } 0\mod3, \text{ except that } \langle \text{RESET} \rangle \text{ resets the count to 0}\}
$$

### [1.1.3] Formal Definition of Computation
---
위에서 우리는 finite automaton을 $\text{5-tuple}$의 formal definition으로 나타내었다. 이와 같은 방식으로 이제 finite automaton이 computation하는 방식을 수학적으로 formalize 해보자.

- $M = (Q, \Sigma, \delta, q_0, F)$에 대하여 $\Sigma$의 각 원소로 구성된 string을 $w = w_1 w_2 \dots w_n$라 하자.
- $M$은 다음 조건을 만족하는 $w$를 $\textbf{accept}$ 한다. ($r_0, r_1, \dots, r_n$ 은 $Q$의 원소, 즉 states)
1. $ r_0 = q_0 $
2. $ \delta(r_i, w_{i+1}) = r_{i+1}, \text{ for } i = 0, \dots, n-1$
3. $r_n \in F$

- $$A = \{w \mid M\ \text{accepts}\ w \}$$ 이면 $M\ \textbf{ recognizes language }\ A$ 라고 한다.

> $\text{A language is called a } \textcolor{red}{\textbf{regular language}} \text{ if some finite automaton recognizes it.}$
{: .prompt-info}

![chomsky](assets/img/school_comp/chomsky.png){: style="margin-left: auto; margin-right: auto; width: 50%;"}

위에서 다룬 $L(M_1), \dots, L(M_5)$는 모두 $\text{regular language}$라고 할 수 있다.


